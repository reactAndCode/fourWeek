# 데이터베이스 스키마

## Supabase 연결 정보

프로젝트의 Supabase 연결 정보는 `.env.local` 파일을 참조하세요.

```bash
NEXT_PUBLIC_SUPABASE_URL=your-project-url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
```

## 테이블 설계

### 1. my_weeklog (주간 작업일지)

하루 단위의 작업 일지를 저장하는 메인 테이블입니다.

**칼럼 구조:**
- `id`: UUID, Primary Key
- `user_id`: UUID, Foreign Key (auth.users), 사용자 식별
- `work_date`: DATE, NOT NULL, 작업 날짜
- `total_minutes`: INTEGER, DEFAULT 0, 총 작업 시간(분)
- `status`: TEXT, CHECK ('draft', 'completed', 'empty'), 작성 상태
  - `draft`: 임시 저장
  - `completed`: 작성 완료
  - `empty`: 일지 없음
- `created_at`: TIMESTAMPTZ, DEFAULT now()
- `updated_at`: TIMESTAMPTZ, DEFAULT now()

**인덱스:**
- PK: `id`
- Unique Index: `user_id + work_date` (한 사용자가 같은 날짜에 하나의 일지만 가짐)
- Index: `user_id + work_date DESC` (날짜별 조회 최적화)

### 2. my_weeklog_task (작업 상세 항목)

주간 작업일지의 개별 작업 항목을 저장하는 테이블입니다.

**칼럼 구조:**
- `id`: UUID, Primary Key
- `weeklog_id`: UUID, Foreign Key (my_weeklog), NOT NULL
- `description`: TEXT, NOT NULL, 작업 설명
- `minutes`: INTEGER, DEFAULT 0, 작업 소요 시간(분)
- `category`: TEXT, CHECK ('design', 'planning', 'development', 'analysis')
  - `design`: 디자인
  - `planning`: 기획
  - `development`: 개발
  - `analysis`: 분석
- `tags`: TEXT[], 작업 태그 배열 (예: ['디자인', '기획'])
- `sort_order`: INTEGER, DEFAULT 0, 작업 표시 순서
- `created_at`: TIMESTAMPTZ, DEFAULT now()

**인덱스:**
- PK: `id`
- Index: `weeklog_id + sort_order` (일지별 작업 조회 최적화)

### 3. my_memo (메모)

사용자의 메모를 저장하는 테이블입니다.

**칼럼 구조:**
- `id`: UUID, Primary Key
- `user_id`: UUID, Foreign Key (auth.users), NOT NULL
- `title`: TEXT, NOT NULL, 메모 제목
- `content`: TEXT, NOT NULL, 메모 내용
- `tags`: TEXT[], 메모 태그 배열
- `is_pinned`: BOOLEAN, DEFAULT false, 상단 고정 여부
- `created_at`: TIMESTAMPTZ, DEFAULT now()
- `updated_at`: TIMESTAMPTZ, DEFAULT now()

**인덱스:**
- PK: `id`
- Index: `user_id + created_at DESC` (사용자별 최신 메모 조회)
- Index: `user_id + is_pinned DESC, created_at DESC` (고정 메모 우선 표시)

## 테이블 생성 SQL

```sql
-- ============================================
-- 1. my_weeklog 테이블 생성
-- ============================================
CREATE TABLE my_weeklog (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  work_date DATE NOT NULL,
  total_minutes INTEGER DEFAULT 0 CHECK (total_minutes >= 0),
  status TEXT DEFAULT 'empty' CHECK (status IN ('draft', 'completed', 'empty')),
  created_at TIMESTAMPTZ DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT timezone('utc'::text, now()) NOT NULL,

  -- 한 사용자는 하루에 하나의 일지만 작성
  CONSTRAINT unique_user_date UNIQUE (user_id, work_date)
);

-- my_weeklog 인덱스
CREATE INDEX idx_my_weeklog_user_date
  ON my_weeklog(user_id, work_date DESC);

-- my_weeklog 코멘트
COMMENT ON TABLE my_weeklog IS '주간 작업일지 메인 테이블';
COMMENT ON COLUMN my_weeklog.work_date IS '작업 날짜';
COMMENT ON COLUMN my_weeklog.total_minutes IS '총 작업 시간(분)';
COMMENT ON COLUMN my_weeklog.status IS '작성 상태: draft(임시저장), completed(작성완료), empty(일지없음)';

-- ============================================
-- 2. my_weeklog_task 테이블 생성
-- ============================================
CREATE TABLE my_weeklog_task (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  weeklog_id UUID REFERENCES my_weeklog(id) ON DELETE CASCADE NOT NULL,
  description TEXT NOT NULL,
  minutes INTEGER DEFAULT 0 CHECK (minutes >= 0),
  category TEXT NOT NULL CHECK (category IN ('design', 'planning', 'development', 'analysis')),
  tags TEXT[] DEFAULT ARRAY[]::TEXT[],
  sort_order INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- my_weeklog_task 인덱스
CREATE INDEX idx_my_weeklog_task_weeklog
  ON my_weeklog_task(weeklog_id, sort_order);

-- my_weeklog_task 코멘트
COMMENT ON TABLE my_weeklog_task IS '작업 일지의 개별 작업 항목';
COMMENT ON COLUMN my_weeklog_task.description IS '작업 설명';
COMMENT ON COLUMN my_weeklog_task.minutes IS '작업 소요 시간(분)';
COMMENT ON COLUMN my_weeklog_task.category IS '작업 카테고리: design(디자인), planning(기획), development(개발), analysis(분석)';
COMMENT ON COLUMN my_weeklog_task.tags IS '작업 태그 배열';
COMMENT ON COLUMN my_weeklog_task.sort_order IS '작업 표시 순서';

-- ============================================
-- 3. my_memo 테이블 생성
-- ============================================
CREATE TABLE my_memo (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  tags TEXT[] DEFAULT ARRAY[]::TEXT[],
  is_pinned BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- my_memo 인덱스
CREATE INDEX idx_my_memo_user_created
  ON my_memo(user_id, created_at DESC);

CREATE INDEX idx_my_memo_user_pinned
  ON my_memo(user_id, is_pinned DESC, created_at DESC);

-- my_memo 코멘트
COMMENT ON TABLE my_memo IS '사용자 메모 테이블';
COMMENT ON COLUMN my_memo.title IS '메모 제목';
COMMENT ON COLUMN my_memo.content IS '메모 내용';
COMMENT ON COLUMN my_memo.tags IS '메모 태그 배열';
COMMENT ON COLUMN my_memo.is_pinned IS '상단 고정 여부';

-- ============================================
-- 4. Row Level Security (RLS) 정책
-- ============================================

-- my_weeklog RLS 활성화
ALTER TABLE my_weeklog ENABLE ROW LEVEL SECURITY;

-- 사용자는 자신의 일지만 조회 가능
CREATE POLICY "사용자는 자신의 주간일지를 조회할 수 있습니다"
  ON my_weeklog FOR SELECT
  USING (auth.uid() = user_id);

-- 사용자는 자신의 일지만 생성 가능
CREATE POLICY "사용자는 자신의 주간일지를 생성할 수 있습니다"
  ON my_weeklog FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- 사용자는 자신의 일지만 수정 가능
CREATE POLICY "사용자는 자신의 주간일지를 수정할 수 있습니다"
  ON my_weeklog FOR UPDATE
  USING (auth.uid() = user_id);

-- 사용자는 자신의 일지만 삭제 가능
CREATE POLICY "사용자는 자신의 주간일지를 삭제할 수 있습니다"
  ON my_weeklog FOR DELETE
  USING (auth.uid() = user_id);

-- my_weeklog_task RLS 활성화
ALTER TABLE my_weeklog_task ENABLE ROW LEVEL SECURITY;

-- 사용자는 자신의 일지에 속한 작업만 조회 가능
CREATE POLICY "사용자는 자신의 작업을 조회할 수 있습니다"
  ON my_weeklog_task FOR SELECT
  USING (EXISTS (
    SELECT 1 FROM my_weeklog
    WHERE my_weeklog.id = my_weeklog_task.weeklog_id
    AND my_weeklog.user_id = auth.uid()
  ));

-- 사용자는 자신의 일지에만 작업 생성 가능
CREATE POLICY "사용자는 자신의 작업을 생성할 수 있습니다"
  ON my_weeklog_task FOR INSERT
  WITH CHECK (EXISTS (
    SELECT 1 FROM my_weeklog
    WHERE my_weeklog.id = my_weeklog_task.weeklog_id
    AND my_weeklog.user_id = auth.uid()
  ));

-- 사용자는 자신의 작업만 수정 가능
CREATE POLICY "사용자는 자신의 작업을 수정할 수 있습니다"
  ON my_weeklog_task FOR UPDATE
  USING (EXISTS (
    SELECT 1 FROM my_weeklog
    WHERE my_weeklog.id = my_weeklog_task.weeklog_id
    AND my_weeklog.user_id = auth.uid()
  ));

-- 사용자는 자신의 작업만 삭제 가능
CREATE POLICY "사용자는 자신의 작업을 삭제할 수 있습니다"
  ON my_weeklog_task FOR DELETE
  USING (EXISTS (
    SELECT 1 FROM my_weeklog
    WHERE my_weeklog.id = my_weeklog_task.weeklog_id
    AND my_weeklog.user_id = auth.uid()
  ));

-- my_memo RLS 활성화
ALTER TABLE my_memo ENABLE ROW LEVEL SECURITY;

-- 사용자는 자신의 메모만 조회 가능
CREATE POLICY "사용자는 자신의 메모를 조회할 수 있습니다"
  ON my_memo FOR SELECT
  USING (auth.uid() = user_id);

-- 사용자는 자신의 메모만 생성 가능
CREATE POLICY "사용자는 자신의 메모를 생성할 수 있습니다"
  ON my_memo FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- 사용자는 자신의 메모만 수정 가능
CREATE POLICY "사용자는 자신의 메모를 수정할 수 있습니다"
  ON my_memo FOR UPDATE
  USING (auth.uid() = user_id);

-- 사용자는 자신의 메모만 삭제 가능
CREATE POLICY "사용자는 자신의 메모를 삭제할 수 있습니다"
  ON my_memo FOR DELETE
  USING (auth.uid() = user_id);

-- ============================================
-- 5. 트리거 함수 (updated_at 자동 갱신)
-- ============================================

-- updated_at 자동 갱신 함수
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = timezone('utc'::text, now());
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- my_weeklog 트리거
CREATE TRIGGER update_my_weeklog_updated_at
  BEFORE UPDATE ON my_weeklog
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- my_memo 트리거
CREATE TRIGGER update_my_memo_updated_at
  BEFORE UPDATE ON my_memo
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- 6. total_minutes 자동 계산 트리거
-- ============================================

-- weeklog의 total_minutes를 자동으로 계산하는 함수
CREATE OR REPLACE FUNCTION calculate_weeklog_total_minutes()
RETURNS TRIGGER AS $$
BEGIN
  -- INSERT, UPDATE, DELETE 작업 시 해당 weeklog의 total_minutes 재계산
  UPDATE my_weeklog
  SET total_minutes = (
    SELECT COALESCE(SUM(minutes), 0)
    FROM my_weeklog_task
    WHERE weeklog_id = COALESCE(NEW.weeklog_id, OLD.weeklog_id)
  )
  WHERE id = COALESCE(NEW.weeklog_id, OLD.weeklog_id);

  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- task 생성/수정/삭제 시 total_minutes 자동 계산
CREATE TRIGGER update_weeklog_total_minutes
  AFTER INSERT OR UPDATE OR DELETE ON my_weeklog_task
  FOR EACH ROW
  EXECUTE FUNCTION calculate_weeklog_total_minutes();
```

## 샘플 데이터 삽입

```sql
-- 주간일지 샘플 데이터 (user_id는 실제 사용자 ID로 변경 필요)
INSERT INTO my_weeklog (user_id, work_date, status)
VALUES
  ('YOUR_USER_ID', '2023-10-23', 'completed'),
  ('YOUR_USER_ID', '2023-10-24', 'draft'),
  ('YOUR_USER_ID', '2023-10-25', 'completed');

-- 작업 항목 샘플 데이터
INSERT INTO my_weeklog_task (weeklog_id, description, minutes, category, tags, sort_order)
SELECT
  wl.id,
  'UI 디자인 시스템 컴포넌트 개발',
  480,
  'design',
  ARRAY['디자인', '기획'],
  1
FROM my_weeklog wl
WHERE wl.work_date = '2023-10-23'
LIMIT 1;

-- 메모 샘플 데이터
INSERT INTO my_memo (user_id, title, content, tags, is_pinned)
VALUES
  ('YOUR_USER_ID', '프로젝트 회의록', '주간 회의 내용...', ARRAY['회의', '기획'], false);
```

## 조회 쿼리 예시

```sql
-- 특정 주의 작업일지 조회 (작업 항목 포함)
SELECT
  wl.*,
  json_agg(
    json_build_object(
      'id', wlt.id,
      'description', wlt.description,
      'minutes', wlt.minutes,
      'category', wlt.category,
      'tags', wlt.tags
    ) ORDER BY wlt.sort_order
  ) as tasks
FROM my_weeklog wl
LEFT JOIN my_weeklog_task wlt ON wl.id = wlt.weeklog_id
WHERE wl.user_id = 'YOUR_USER_ID'
  AND wl.work_date BETWEEN '2023-10-23' AND '2023-10-29'
GROUP BY wl.id
ORDER BY wl.work_date;

-- 주간 통계 계산
SELECT
  SUM(total_minutes) as total_minutes,
  COUNT(DISTINCT id) FILTER (WHERE status = 'completed') as completed_count,
  ROUND(
    COUNT(DISTINCT id) FILTER (WHERE status = 'completed')::numeric /
    NULLIF(COUNT(DISTINCT id), 0) * 100
  ) as progress_rate
FROM my_weeklog
WHERE user_id = 'YOUR_USER_ID'
  AND work_date BETWEEN '2023-10-23' AND '2023-10-29';
```

## 테이블 삭제 (필요시)

```sql
-- 역순으로 삭제 (외래키 제약 때문)
DROP TABLE IF EXISTS my_weeklog_task CASCADE;
DROP TABLE IF EXISTS my_weeklog CASCADE;
DROP TABLE IF EXISTS my_memo CASCADE;
DROP FUNCTION IF EXISTS update_updated_at_column() CASCADE;
DROP FUNCTION IF EXISTS calculate_weeklog_total_minutes() CASCADE;
```

## 참고사항

1. **Supabase 대시보드에서 실행**: 위 SQL 스크립트는 Supabase 프로젝트의 SQL Editor에서 실행하세요.

2. **인증 필요**: 테이블을 사용하기 전에 Supabase Auth를 통해 사용자 인증을 구현해야 합니다.

3. **타입 정의 생성**: 테이블 생성 후 TypeScript 타입을 자동 생성할 수 있습니다:
   ```bash
   npx supabase gen types typescript --project-id YOUR_PROJECT_ID > types/database.types.ts
   ```

4. **마이그레이션**: 프로덕션 환경에서는 Supabase CLI를 사용하여 마이그레이션을 관리하는 것을 권장합니다.
